import os
import json
import re
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel
from openai import OpenAI

client = OpenAI()

# ============================================================
# PATH / FILE
# ============================================================
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
STATIC_DIR = os.path.join(BASE_DIR, "static")
DATA_DIR = os.path.join(STATIC_DIR, "data")
MASTER_PATH = os.path.join(DATA_DIR, "ctf_system_COMPLETE_GOLD_master.json")

# ============================================================
# FASTAPI SETUP
# ============================================================
app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================
# LOAD MASTER
# ============================================================
def load_master():
    with open(MASTER_PATH, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data.get("blocks", [])

MASTER_BLOCKS = load_master()

# ============================================================
# MODEL REQUEST
# ============================================================
class AskRequest(BaseModel):
    question: str
    lang: str = "it"

# ============================================================
# HELPERS
# ============================================================
def normalize(text: str) -> str:
    text = text.lower()
    text = re.sub(r"[^a-z0-9àèéìòùç_\- ]+", " ", text)
    return re.sub(r"\s+", " ", text).strip()


def lexical_match_score(q_norm, block):
    """Punteggio semplice basato su parole chiave."""
    score = 0
    for trig in block.get("triggers", []):
        trig_norm = normalize(trig)
        if trig_norm in q_norm:
            score += 3
        elif any(t in q_norm for t in trig_norm.split()):
            score += 1
    return score


def pick_internal_answer(question: str):
    """Matching interno classico."""
    q_norm = normalize(question)
    candidates = []

    for blk in MASTER_BLOCKS:
        score = lexical_match_score(q_norm, blk)
        if score > 0:
            candidates.append((score, blk))

    if not candidates:
        return None

    candidates.sort(key=lambda x: x[0], reverse=True)
    return candidates[0][1]


def ask_external_gpt(question: str):
    """Chiede un parere esterno (ChatGPT) in stile Tecnaria."""
    prompt = f"""
Sei l’assistente tecnico di Tecnaria. Rispondi in modo tecnico e conciso.
Domanda: {question}
Risposta:
"""
    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2,
        )
        return resp.choices[0].message.content.strip()
    except Exception:
        return None


def choose_best_answer(user_question: str, internal: str, external: str):
    """Judge: decide se è migliore interna o esterna."""
    if internal and not external:
        return internal, "internal"
    if external and not internal:
        return external, "external"
    if not internal and not external:
        return None, None

    prompt = f"""
Sei un giudice Tecnaria.

Domanda: {user_question}

Risposta A (interna):
{internal}

Risposta B (esterna):
{external}

Quale risposta è TECNICAMENTE più corretta, precisa e coerente con il dominio CTF/P560 Tecnaria?
Rispondi SOLO con: A oppure B.
"""

    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0,
        )
        judge = resp.choices[0].message.content.strip()

        if judge == "A":
            return internal, "internal"
        else:
            return external, "external"
    except:
        return internal, "internal"


def save_new_block(question: str, answer: str):
    """Salva automaticamente una nuova GOLD block se la risposta viene dall’esterno."""
    new_block = {
        "id": f"AUTO-{len(MASTER_BLOCKS)+1:05d}",
        "family": "AUTO",
        "mode": "gold",
        "lang": "it",
        "intent": "auto_generated",
        "tags": ["auto", "external", "generated"],
        "triggers": [question],
        "question_it": question,
        "answer_it": answer,
    }

    MASTER_BLOCKS.append(new_block)

    with open(MASTER_PATH, "w", encoding="utf-8") as f:
        json.dump({"blocks": MASTER_BLOCKS}, f, indent=2, ensure_ascii=False)


# ============================================================
# ROUTES
# ============================================================

@app.get("/", response_class=FileResponse)
def home():
    """Ripristina la UI."""
    return FileResponse(os.path.join(STATIC_DIR, "index.html"))


@app.get("/health")
def health():
    return {"status": "ok", "blocks": len(MASTER_BLOCKS)}


@app.post("/api/ask")
def api_ask(req: AskRequest):
    user_q = req.question.strip()

    # 1) Matching interno
    internal_block = pick_internal_answer(user_q)
    internal_answer = (
        internal_block["answer_it"] if internal_block else None
    )

    # 2) Risposta esterna ChatGPT
    external_answer = ask_external_gpt(user_q)

    # 3) Judge
    final_answer, origin = choose_best_answer(
        user_q, internal_answer, external_answer
    )

    if final_answer is None:
        return {
            "answer": "Nessuna risposta trovata.",
            "origin": "none",
        }

    # Salvataggio automatico dei nuovi blocchi
    if origin == "external":
        save_new_block(user_q, final_answer)

    return {
        "answer": final_answer,
        "origin": origin,
    }
