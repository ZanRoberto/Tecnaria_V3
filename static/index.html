import os
import json
import re
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel
from openai import OpenAI
from fastapi.staticfiles import StaticFiles

client = OpenAI()

# ============================================================
# PATH / FILE
# ============================================================
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Static folder detection (robusta)
STATIC_DIR = os.path.join(BASE_DIR, "static")
if not os.path.exists(STATIC_DIR):
    STATIC_DIR = "static"

DATA_DIR = os.path.join(STATIC_DIR, "data")
MASTER_PATH = os.path.join(DATA_DIR, "ctf_system_COMPLETE_GOLD_master.json")

# ============================================================
# FASTAPI SETUP
# ============================================================
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Serve static files ALWAYS
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")


# ============================================================
# LOAD MASTER
# ============================================================
def load_master():
    with open(MASTER_PATH, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data.get("blocks", [])

MASTER_BLOCKS = load_master()

# ============================================================
# MODEL REQUEST
# ============================================================
class AskRequest(BaseModel):
    question: str
    lang: str = "it"

# ============================================================
# NORMALIZATION
# ============================================================
def normalize(text: str) -> str:
    text = text.lower()
    text = re.sub(r"[^a-z0-9àèéìòùç_\- ]+", " ", text)
    return re.sub(r"\s+", " ", text).strip()

# ============================================================
# INTERNAL MATCHING
# ============================================================
def lexical_match_score(q_norm, block):
    score = 0
    for trig in block.get("triggers", []):
        trig_norm = normalize(trig)
        if trig_norm in q_norm:
            score += 3
        elif any(t in q_norm for t in trig_norm.split()):
            score += 1
    return score

def pick_internal_answer(question: str):
    q_norm = normalize(question)
    candidates = []
    for blk in MASTER_BLOCKS:
        score = lexical_match_score(q_norm, blk)
        if score > 0:
            candidates.append((score, blk))
    if not candidates:
        return None
    candidates.sort(key=lambda x: x[0], reverse=True)
    return candidates[0][1]


# ============================================================
# EXTERNAL GPT
# ============================================================
def ask_external_gpt(question: str):
    prompt = f"""
Rispondi come assistente tecnico Tecnaria.
Domanda: {question}
Risposta:"""

    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
        )
        return resp.choices[0].message.content.strip()
    except:
        return None


# ============================================================
# JUDGE
# ============================================================
def choose_best_answer(user_question: str, internal: str, external: str):
    if internal and not external:
        return internal, "internal"
    if external and not internal:
        return external, "external"
    if not internal and not external:
        return None, None

    judge_prompt = f"""
Sei un giudice tecnico Tecnaria.
Scegli quale risposta è tecnicamente più corretta.

DOMANDA: {user_question}

RISPOSTA A (interna):
{internal}

RISPOSTA B (esterna):
{external}

Rispondi SOLO con 'A' o 'B'.
"""

    try:
        resp = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": judge_prompt}],
            temperature=0,
        )
        judge = resp.choices[0].message.content.strip()

        if judge == "A":
            return internal, "internal"
        else:
            return external, "external"
    except:
        return internal, "internal"

# ============================================================
# AUTO SAVE
# ============================================================
def save_new_block(question: str, answer: str):
    new_block = {
        "id": f"AUTO-{len(MASTER_BLOCKS)+1:05d}",
        "family": "AUTO",
        "mode": "gold",
        "lang": "it",
        "intent": "auto_generated",
        "tags": ["auto", "external", "generated"],
        "triggers": [question],
        "question_it": question,
        "answer_it": answer,
    }

    MASTER_BLOCKS.append(new_block)

    with open(MASTER_PATH, "w", encoding="utf-8") as f:
        json.dump({"blocks": MASTER_BLOCKS}, f, indent=2, ensure_ascii=False)


# ============================================================
# ROUTES
# ============================================================

@app.get("/")
def home():
    """FORZA SEMPRE IL RENDERING DELL’INTERFACCIA."""
    index_path = os.path.join(STATIC_DIR, "index.html")
    if os.path.exists(index_path):
        return FileResponse(index_path)
    return {"error": f"index.html non trovato in {index_path}"}


@app.get("/health")
def health():
    return {"status": "ok", "blocks": len(MASTER_BLOCKS)}


@app.post("/api/ask")
def api_ask(req: AskRequest):
    user_q = req.question.strip()

    # 1) internal
    internal_block = pick_internal_answer(user_q)
    internal_answer = internal_block["answer_it"] if internal_block else None

    # 2) external
    external_answer = ask_external_gpt(user_q)

    # 3) judge
    final, origin = choose_best_answer(user_q, internal_answer, external_answer)

    if final is None:
        return {"answer": "Nessuna risposta trovata.", "origin": "none"}

    # 4) auto-add blocks
    if origin == "external":
        save_new_block(user_q, final)

    return {"answer": final, "origin": origin}
