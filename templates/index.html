<script>
  // -----------------------
  // Config
  // -----------------------
  const ASK_ENDPOINT = "/ask";   // deve esistere in app.py
  const MAX_SHOW_DEBUG = false;  // interfaccia pulita

  // -----------------------
  // UI helpers
  // -----------------------
  const $messages = document.getElementById('messages');
  const $input = document.getElementById('q');
  const $send = document.getElementById('send');
  const $mic  = document.getElementById('mic');
  const $welcome = document.getElementById('welcome-text');

  function el(tag, cls){ const n=document.createElement(tag); if(cls) n.className=cls; return n; }
  function addMsg(role, text){
    const row = el('div', `msg ${role}`);
    const avatar = el('div','avatar'); avatar.textContent = role==='user' ? 'TU' : 'AI';
    const content = el('div','content'); content.textContent = text;
    row.appendChild(avatar); row.appendChild(content);
    $messages.appendChild(row);
    $messages.scrollTop = $messages.scrollHeight;
    if($welcome) $welcome.parentElement.parentElement.classList.add('hidden');
  }
  function setBusy(b){ document.querySelector('main').setAttribute('aria-busy', b ? 'true' : 'false'); }

  async function ask(q){
    if(!q || !q.trim()) return;
    addMsg('user', q.trim());
    setBusy(true);
    $send.disabled = true;
    try{
      const res = await fetch(ASK_ENDPOINT, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ question: q.trim() })
      });
      if(!res.ok){ addMsg('bot','âš ï¸ Errore di rete. Riprova.'); return; }
      const data = await res.json();
      let text = (data && data.answer) ? data.answer : "Non ho trovato una risposta precisa nei documenti locali.";
      addMsg('bot', text);
      if(MAX_SHOW_DEBUG && data){
        addMsg('bot', `â€” debug â€”\nfound: ${data.found}\nscore: ${data.score}\nfile: ${data.path || '-'}\nlinea: ${data.line || '-'}`);
      }
    }catch(e){
      addMsg('bot','âš ï¸ Errore temporaneo. Riprova.');
    }finally{
      setBusy(false); $send.disabled = false;
    }
  }

  // Invio con click o Invio
  $send.addEventListener('click', () => { ask($input.value); $input.value=''; });
  $input.addEventListener('keydown', (e) => { if(e.key==='Enter'){ ask($input.value); $input.value=''; } });

  // -----------------------
  // Microfono robusto
  // -----------------------
  let rec = null;
  let recording = false;
  let mediaReady = false; // true dopo getUserMedia ok
  let stopTimer = null;

  function supportedSpeech(){
    return ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window);
  }

  async function ensureMicPermission(){
    // Serve solo a mostrare il prompt di permesso microfono una volta
    if(mediaReady) return true;
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return true; // non blocchiamo se non disponibile
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      // chiudi subito le tracce: ci serviva solo il permesso
      stream.getTracks().forEach(t => t.stop());
      mediaReady = true;
      return true;
    }catch(err){
      addMsg('bot','Per usare il microfono, consenti lâ€™accesso (icona ðŸ”’ in alto â†’ Microfono â†’ Consenti).');
      return false;
    }
  }

  function createRecognizer(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SR) return null;
    const r = new SR();
    r.lang = 'it-IT';
    r.interimResults = false;
    r.maxAlternatives = 1;
    r.continuous = false; // sessioni brevi, piÃ¹ stabili
    r.onresult = (ev) => {
      const text = ev.results && ev.results[0] && ev.results[0][0] && ev.results[0][0].transcript;
      if(text){ $input.value = text; ask(text); $input.value=''; }
    };
    r.onerror = (e) => {
      // errori tipici: 'no-speech', 'audio-capture', 'not-allowed', 'aborted'
      if(e && e.error === 'not-allowed'){
        addMsg('bot','Devi consentire il microfono (icona ðŸ”’ in alto).');
      }else if(e && e.error === 'no-speech'){
        addMsg('bot','Non ho captato audio. Prova a parlare piÃ¹ vicino al microfono.');
      }else{
        addMsg('bot','âš ï¸ Il riconoscimento vocale si Ã¨ interrotto. Riprova.');
      }
      $mic.classList.remove('recording'); recording = false;
    };
    r.onend = () => {
      $mic.classList.remove('recording'); recording = false;
      if(stopTimer){ clearTimeout(stopTimer); stopTimer = null; }
    };
    return r;
  }

  async function startRecognition(){
    if(!supportedSpeech()){
      addMsg('bot','Il microfono non Ã¨ supportato da questo browser. Usa Chrome o Edge su desktop.');
      return;
    }
    const ok = await ensureMicPermission();
    if(!ok) return;

    if(!rec){ rec = createRecognizer(); }
    if(!rec){
      addMsg('bot','Il riconoscimento vocale non Ã¨ disponibile su questo dispositivo.');
      return;
    }
    if(recording){ // se era giÃ  attivo, fermiamo e riavviamo pulito
      try{ rec.stop(); }catch(_){}
      recording = false;
      $mic.classList.remove('recording');
    }
    try{
      rec.start();
      recording = true;
      $mic.classList.add('recording');
      // sicurezza: auto-stop dopo 10s per evitare sessioni â€œbloccateâ€
      if(stopTimer){ clearTimeout(stopTimer); }
      stopTimer = setTimeout(() => {
        try{ rec.stop(); }catch(_){}
      }, 10000);
    }catch(e){
      // spesso â€œstartâ€ lanciato due volte genera eccezione
      addMsg('bot','Il microfono Ã¨ occupato. Attendi un secondo e riprova.');
      recording = false;
      $mic.classList.remove('recording');
    }
  }

  $mic.addEventListener('click', () => {
    // gesto utente garantito
    startRecognition();
  });
</script>
